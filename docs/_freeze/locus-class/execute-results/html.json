{
  "hash": "a0a61a318cf66064cba51b25d1143ed5",
  "result": {
    "engine": "knitr",
    "markdown": "# The Locus Class\n\nThe `locus` is the fundamental data type in `gstudio`. It is an S3 class that stores a genotype as a colon-separated string of alleles. This chapter covers creating, manipulating, and converting locus objects.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(gstudio)\n```\n:::\n\n\n## Creating Locus Objects\n\nThe `locus()` constructor takes a vector of alleles and collapses them into a single genotype:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nloc <- locus(c(\"A\", \"B\"))\nloc\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"A:B\"\n```\n\n\n:::\n:::\n\n\nHomozygotes and higher-ploidy genotypes work the same way:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlocus(c(\"A\", \"A\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"A:A\"\n```\n\n\n:::\n\n```{.r .cell-code}\nlocus(c(\"A\", \"B\", \"C\", \"D\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"A:B:C:D\"\n```\n\n\n:::\n:::\n\n\n### Missing Data\n\nMissing data is represented as an empty string internally:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nloc_missing <- locus()\nloc_missing\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nis.na(loc_missing)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n## Marker Types\n\nThe `type` parameter controls how raw data is interpreted:\n\n### Codominant (default)\n\nAlleles are sorted alphabetically and joined with `:`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlocus(c(\"B\", \"A\"), type = \"codom\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"A:B\"\n```\n\n\n:::\n:::\n\n\n### AFLP\n\nBinary presence/absence data (0 or 1):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlocus(\"1\", type = \"aflp\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1\"\n```\n\n\n:::\n\n```{.r .cell-code}\nlocus(\"0\", type = \"aflp\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"0\"\n```\n\n\n:::\n:::\n\n\n### SNP\n\nEncoded as 0, 1, or 2 (count of minor alleles):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlocus(\"0\", type = \"snp\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"A:A\"\n```\n\n\n:::\n\n```{.r .cell-code}\nlocus(\"1\", type = \"snp\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"A:B\"\n```\n\n\n:::\n\n```{.r .cell-code}\nlocus(\"2\", type = \"snp\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"B:B\"\n```\n\n\n:::\n:::\n\n\n### Separated\n\nPre-formatted colon-separated strings:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlocus(\"A:B\", type = \"separated\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"A:B\"\n```\n\n\n:::\n:::\n\n\n### Zyme (allozyme)\n\nAlleles encoded as concatenated integers (e.g., \"12\" = alleles 1 and 2):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlocus(\"12\", type = \"zyme\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1:2\"\n```\n\n\n:::\n\n```{.r .cell-code}\nlocus(\"23\", type = \"zyme\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2:3\"\n```\n\n\n:::\n:::\n\n\n### Column\n\nTwo-column matrix format (used internally by `read_population()`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nalleles_mat <- cbind(c(\"A\", \"B\", \"C\"), c(\"B\", \"A\", \"C\"))\nlocus(alleles_mat, type = \"column\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"A:B\" \"A:B\" \"C:C\"\n```\n\n\n:::\n:::\n\n\n## Working with Vectors of Loci\n\nGenotype vectors are created using `c()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nAA <- locus(c(\"A\", \"A\"))\nAB <- locus(c(\"A\", \"B\"))\nBB <- locus(c(\"B\", \"B\"))\nloci <- c(AA, AB, AB, AA, BB)\nloci\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"A:A\" \"A:B\" \"A:B\" \"A:A\" \"B:B\"\n```\n\n\n:::\n:::\n\n\n### Indexing\n\n\n::: {.cell}\n\n```{.r .cell-code}\nloci[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"A:B\"\n```\n\n\n:::\n\n```{.r .cell-code}\nloci[c(1, 3, 5)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"A:A\" \"A:B\" \"B:B\"\n```\n\n\n:::\n:::\n\n\n### Replication\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrep(AB, times = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"A:B\" \"A:B\" \"A:B\"\n```\n\n\n:::\n:::\n\n\n## Extracting Alleles\n\nThe `alleles()` function returns the component alleles:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nalleles(AB)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"A\" \"B\"\n```\n\n\n:::\n\n```{.r .cell-code}\nalleles(loci)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,] \"A\"  \"A\" \n[2,] \"A\"  \"B\" \n[3,] \"A\"  \"B\" \n[4,] \"A\"  \"A\" \n[5,] \"B\"  \"B\" \n```\n\n\n:::\n:::\n\n\n## Heterozygosity Testing\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis_heterozygote(AA)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nis_heterozygote(AB)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nis_heterozygote(loci)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE  TRUE FALSE FALSE\n```\n\n\n:::\n:::\n\n\n## Operator Overloads\n\n### Mating (`+`)\n\nThe `+` operator simulates mating by randomly sampling one allele from each parent:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndad <- locus(c(\"A\", \"A\"))\nmom <- locus(c(\"B\", \"B\"))\nset.seed(42)\noffspring <- mom + dad\noffspring\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"A:B\"\n```\n\n\n:::\n:::\n\n\n### Parental Subtraction (`-`)\n\nThe `-` operator removes the maternal contribution from an offspring genotype:\n\n\n::: {.cell}\n\n```{.r .cell-code}\noff <- locus(c(\"A\", \"B\"))\nmom <- locus(c(\"A\", \"A\"))\npaternal_gamete <- off - mom\npaternal_gamete\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"B\"\n```\n\n\n:::\n:::\n\n\nThis is useful in parentage analysis for identifying the paternal allelic contribution.\n\n## Coercion\n\n### To Data Frame\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.data.frame(loci)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  loci\n1  A:A\n2  A:B\n3  A:B\n4  A:A\n5  B:B\n```\n\n\n:::\n:::\n\n\n### From Other Types\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.locus(c(\"A\", \"B\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"A:B\"\n```\n\n\n:::\n\n```{.r .cell-code}\nas.locus(list(\"C\", \"D\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"C:D\"\n```\n\n\n:::\n:::\n\n\n### Is-a Test\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.locus(AB)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.locus(\"not a locus\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n## Multivariate Conversion\n\nThe `to_mv()` function converts locus data to a multivariate numeric format suitable for ordination and graph analysis:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(arapat)\nmv <- to_mv(arapat)\ndim(mv)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 363  58\n```\n\n\n:::\n\n```{.r .cell-code}\nmv[1:5, 1:6]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     01 02  01 02  03 04\n[1,]  1  0 0.0  0 0.0  0\n[2,]  1  0 0.5  0 0.5  0\n[3,]  1  0 0.5  0 0.5  0\n[4,]  1  0 1.0  0 0.0  0\n[5,]  1  0 0.5  0 0.5  0\n```\n\n\n:::\n:::\n\n\nEach allele at each locus becomes a column, with values representing allele counts (0, 1, or 2 for diploids). This is the input format for `popgraph()`.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}