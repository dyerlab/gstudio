{
  "hash": "4aeea7fac3a7c866012b096ccf411556",
  "result": {
    "engine": "knitr",
    "markdown": "# Simulation & Parentage\n\nThis chapter covers the forward-time population simulation framework and parentage analysis tools in `gstudio`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(gstudio)\nlibrary(dplyr, warn.conflicts = FALSE)\n```\n:::\n\n\n## Building Populations from Frequencies\n\n### Allele Frequency Specification\n\nThe simulation tools start with specifying allele frequencies per population and locus. The `make_populations()` function requires a data.frame with `Population`, `Locus`, `Allele`, and `Frequency` columns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf1 <- data.frame(\n  Population = \"A\",\n  Locus = rep(c(\"Loc1\", \"Loc2\", \"Loc3\"), each = 2),\n  Allele = rep(c(\"01\", \"02\"), times = 3),\n  Frequency = c(0.2, 0.8, 0.3, 0.7, 0.4, 0.6)\n)\nf2 <- data.frame(\n  Population = \"B\",\n  Locus = rep(c(\"Loc1\", \"Loc2\", \"Loc3\"), each = 2),\n  Allele = rep(c(\"01\", \"02\"), times = 3),\n  Frequency = c(0.7, 0.3, 0.5, 0.5, 0.6, 0.4)\n)\nf3 <- data.frame(\n  Population = \"C\",\n  Locus = rep(c(\"Loc1\", \"Loc2\", \"Loc3\"), each = 2),\n  Allele = rep(c(\"01\", \"02\"), times = 3),\n  Frequency = c(0.4, 0.6, 0.3, 0.7, 0.2, 0.8)\n)\nfreqs <- rbind(f1, f2, f3)\nfreqs$Population <- factor(freqs$Population, ordered = TRUE)\n```\n:::\n\n\n### Creating Populations\n\n\n::: {.cell}\n\n```{.r .cell-code}\npop <- make_populations(freqs, N = 30)\nhead(pop)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Population ID  Loc1  Loc2  Loc3\n1          A  1 02:02 01:02 01:02\n2          A  2 01:02 01:02 02:02\n3          A  3 02:02 02:02 02:02\n4          A  4 02:02 02:02 01:02\n5          A  5 02:02 01:02 02:02\n6          A  6 02:02 02:02 01:02\n```\n\n\n:::\n\n```{.r .cell-code}\ntable(pop$Population)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n A  B  C \n30 30 30 \n```\n\n\n:::\n:::\n\n\nYou can specify an inbreeding level with `F`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npop_inbred <- make_populations(freqs, N = 30, F = 0.3)\n```\n:::\n\n\n## Migration Models\n\nThe `migration_matrix()` function creates a K x K migration matrix where rows sum to 1. Element `[i,j]` is the proportion of population *i* that originates from population *j*.\n\n### Island Model\n\nEqual migration among all populations:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmigration_matrix(3, model = \"island\", m = 0.05)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      Pop1  Pop2  Pop3\nPop1 0.950 0.025 0.025\nPop2 0.025 0.950 0.025\nPop3 0.025 0.025 0.950\n```\n\n\n:::\n:::\n\n\n### 1D Stepping Stone\n\nMigration only between adjacent populations:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmigration_matrix(c(\"A\", \"B\", \"C\", \"D\"),\n                 model = \"stepping_stone_1d\", m = 0.1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     A    B    C    D\nA 0.90 0.10 0.00 0.00\nB 0.05 0.90 0.05 0.00\nC 0.00 0.05 0.90 0.05\nD 0.00 0.00 0.10 0.90\n```\n\n\n:::\n:::\n\n\n### 2D Stepping Stone\n\nGrid-based adjacency:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmigration_matrix(4, model = \"stepping_stone_2d\",\n                 m = 0.1, nr = 2, nc = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     Pop1 Pop2 Pop3 Pop4\nPop1 0.90 0.05 0.05 0.00\nPop2 0.05 0.90 0.00 0.05\nPop3 0.05 0.00 0.90 0.05\nPop4 0.00 0.05 0.05 0.90\n```\n\n\n:::\n:::\n\n\n### Distance-Based\n\nMigration rate decays with distance:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoords <- matrix(c(0, 0, 1, 0, 0.5, 1), ncol = 2, byrow = TRUE)\nmigration_matrix(3, model = \"distance\", m = 0.1, coords = coords)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          Pop1      Pop2      Pop3\nPop1 0.9000000 0.0527864 0.0472136\nPop2 0.0527864 0.9000000 0.0472136\nPop3 0.0500000 0.0500000 0.9000000\n```\n\n\n:::\n:::\n\n\n## Migration Events\n\nA `migration_event` pairs a migration matrix with a generation interval, allowing temporal regime changes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm1 <- migration_matrix(3, model = \"island\", m = 0.05)\nm2 <- migration_matrix(3, model = \"island\", m = 0.20)\n\n# Low migration for generations 1-50\nevt1 <- migration_event(m1, start = 1, end = 50)\n\n# High migration from generation 51 onward\nevt2 <- migration_event(m2, start = 51)\n```\n:::\n\n\n## Mutation Models\n\nThe `mutation_model()` function defines how alleles mutate during simulation:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Infinite Alleles Model\nmm_iam <- mutation_model(rate = 0.001, model = \"iam\")\n\n# K-Allele Model (10 possible states)\nmm_kam <- mutation_model(rate = 0.001, model = \"kam\", k = 10)\n\n# Stepwise Mutation Model\nmm_smm <- mutation_model(rate = 0.001, model = \"smm\")\n```\n:::\n\n\n## Forward-Time Simulation\n\nThe `simulate_pop()` function runs a multi-generation forward-time simulation. Each generation cycle: census, migrate, mate, mutate.\n\n### Basic Simulation\n\n\n::: {.cell}\n\n```{.r .cell-code}\npop <- make_populations(freqs, N = 30)\nresult <- simulate_pop(pop, ngen = 20, verbose = FALSE)\nhead(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  ID Population  Loc1  Loc2  Loc3\n1  1          A 01:02 01:01 01:02\n2  2          A 02:02 01:01 01:01\n3  3          A 02:02 01:02 02:02\n4  4          A 02:02 01:02 01:02\n5  5          A 02:02 01:02 02:02\n6  6          A 01:02 01:01 01:01\n```\n\n\n:::\n:::\n\n\n### With Migration\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- migration_matrix(3, model = \"island\", m = 0.05)\nevt <- migration_event(m, start = 1)\n\nresult <- simulate_pop(pop, ngen = 20,\n                       migration = evt,\n                       verbose = FALSE)\n```\n:::\n\n\n### With Mutation\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmm <- mutation_model(rate = 0.01, model = \"iam\")\nresult <- simulate_pop(pop, ngen = 20,\n                       mutation = mm,\n                       verbose = FALSE)\n```\n:::\n\n\n### With Mixed Mating (Selfing)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult <- simulate_pop(pop, ngen = 20,\n                       selfing_rate = 0.3,\n                       verbose = FALSE)\n```\n:::\n\n\n### Census Snapshots\n\nSave population snapshots at regular intervals:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult <- simulate_pop(pop, ngen = 100,\n                       census_interval = 25,\n                       census_dir = tempdir(),\n                       verbose = FALSE)\n# Snapshots saved as gen_0025.rds, gen_0050.rds, etc.\n```\n:::\n\n\n### Complete Worked Example\n\nSimulate drift and migration in a 3-population system, then analyze the outcome:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create starting populations\npop <- make_populations(freqs, N = 50)\n\n# Set up island model migration\nm <- migration_matrix(3, model = \"island\", m = 0.02)\nevt <- migration_event(m, start = 1)\n\n# Run simulation\nset.seed(42)\nfinal <- simulate_pop(pop, ngen = 50,\n                      migration = evt,\n                      verbose = FALSE)\n\n# Analyze structure in the final generation\ngenetic_structure(final, stratum = \"Population\", mode = \"Gst\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       Locus       Gst        Hs        Ht        P\n1       Loc1 0.2240740 0.3267340 0.4210891 0.224074\n2       Loc2 0.2950070 0.3156229 0.4476965 0.295007\n3       Loc3 0.1449410 0.4195286 0.4906429 0.144941\n4 Multilocus 0.2188736 1.0618855 1.3594285       NA\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Compare diversity before and after\ngenetic_diversity(pop, stratum = \"Population\", mode = \"He\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Stratum Locus     He\n2        A  Loc1 0.3200\n3        A  Loc2 0.4118\n4        A  Loc3 0.4800\n5        B  Loc1 0.4118\n6        B  Loc2 0.5000\n7        B  Loc3 0.4800\n8        C  Loc1 0.4800\n9        C  Loc2 0.4118\n10       C  Loc3 0.3200\n```\n\n\n:::\n\n```{.r .cell-code}\ngenetic_diversity(final, stratum = \"Population\", mode = \"He\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Stratum Locus     He\n2        A  Loc1 0.0000\n3        A  Loc2 0.4712\n4        A  Loc3 0.4422\n5        B  Loc1 0.4712\n6        B  Loc2 0.0000\n7        B  Loc3 0.4838\n8        C  Loc1 0.4992\n9        C  Loc2 0.4662\n10       C  Loc3 0.3200\n```\n\n\n:::\n:::\n\n\n## Parentage Analysis\n\n### Mating and Offspring\n\nThe `mate()` function creates offspring from two parents:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- data.frame(\n  Locus = rep(paste0(\"Loc\", 1:4), each = 3),\n  Allele = rep(LETTERS[1:3], times = 4),\n  Frequency = rep(c(1/3, 1/3, 1/3), times = 4)\n)\nadults <- make_population(f, N = 20)\noffs <- mate(adults[1, ], adults[2, ], N = 5)\noffs\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  ID Loc1 Loc2 Loc3 Loc4\n1  1  A:C  C:C  B:C  B:C\n2  1  A:A  A:C  B:C  B:C\n3  1  B:C  C:C  B:C  B:C\n4  1  A:C  A:C  B:B  B:C\n5  1  A:B  A:C  B:C  B:C\n```\n\n\n:::\n:::\n\n\n### Maternal Subtraction\n\nThe `minus_mom()` function removes the maternal contribution from offspring genotypes. It takes a single data.frame where mothers have `OffID = 0` and offspring have `OffID != 0`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Combine mother and offspring into one data.frame\nmom_row <- adults[1, ]\nmom_row$OffID <- 0\noffs$OffID <- 1:nrow(offs)\nfamily <- rbind(mom_row, offs)\npaternal <- minus_mom(family)\npaternal\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  ID Loc1 Loc2 Loc3 Loc4 OffID\n2  1  A:C    C  B:C    C     1\n3  1    A  A:C  B:C    C     2\n4  1    B    C  B:C    C     3\n5  1  A:C  A:C    B    C     4\n6  1    B  A:C  B:C    C     5\n```\n\n\n:::\n:::\n\n\n### Fractional Paternity\n\nThe `paternity()` function estimates the probability of each potential father siring each offspring:\n\n\n::: {.cell}\n\n```{.r .cell-code}\noffs$OffID <- 1:nrow(offs)\noffs$MomID <- adults$ID[1]\npat <- paternity(offs, adults[1, ], adults)\nhead(pat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  MomID OffID DadID        Fij\n1     1     1     2 0.29629630\n2     1     1     7 0.14814815\n3     1     1    12 0.14814815\n4     1     1    15 0.14814815\n5     1     1    18 0.14814815\n6     1     1    16 0.07407407\n```\n\n\n:::\n:::\n\n\nThe `Fij` column gives the fractional paternity probability. Use `strict = TRUE` to retain only unambiguous assignments:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npat_strict <- paternity(offs, adults[1, ], adults, strict = TRUE)\npat_strict\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] MomID OffID DadID Fij  \n<0 rows> (or 0-length row.names)\n```\n\n\n:::\n:::\n\n\n### Single-Parent Exclusion\n\nThe `parent_finder()` function identifies compatible parents for each offspring using exclusion. It requires a data.frame with `ID` and `OffID` columns, where adults have `OffID = 0`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Prepare a combined data.frame\nlocus_cols <- column_class(adults, \"locus\")\nadults2 <- adults[, c(\"ID\", locus_cols)]\nadults2$OffID <- 0\noffs2 <- offs[, c(\"ID\", locus_cols)]\noffs2$OffID <- 1:nrow(offs2)\ncombined <- rbind(adults2, offs2)\nresult <- parent_finder(combined)\nhead(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  ID OffID ParentID       T\n1  1     1        1 0.06250\n2  1     1        2 0.06250\n4  1     1        7 0.06250\n6  1     1       15 0.06250\n3  1     1        5 0.03125\n5  1     1       12 0.03125\n```\n\n\n:::\n:::\n\n\n### Identifying Bad Parents\n\nThe `bad_parents()` function flags parent-offspring pairs that are genetically incompatible:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbad_parents(offs, adults)\n```\n:::\n\n\n## Bundled Parentage Datasets\n\nThe `cornus` and `cornus_florida` datasets contain *Cornus florida* genotype data for parentage analysis:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(cornus)\nhead(cornus)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Population SampleID X.Coordinate Y.Coordinate   Cf.G8  Cf.H18   Cf.N5  Cf.N10\n1          2      203         3040         6146 157:165 117:119 170:170 189:191\n2          2      204         3070         6114 159:163 101:103 166:170 193:201\n3          2      205         3096         6148 151:157 113:119         193:195\n4          2      206         3124         6136 153:161 117:119         197:201\n5          2      207         3082         6126 159:163 105:119 158:170 193:193\n6          2      208         3148         5180 181:181 119:119 170:170 199:201\n    Cf.O5\n1 198:198\n2 178:182\n3 178:182\n4 178:198\n5 178:196\n6 176:182\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(cornus_florida)\nhead(cornus_florida)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   ID OffID    X    Y      G8     H18      N5     N10      O5\n1 226     0 1392 3534 162:180 114:114 124:126 192:192 185:195\n2 232     0 1656 3414 158:180 112:112 124:126 184:192 185:185\n3 234     0 1718 3330 158:180  112:96 128:128 184:192 185:185\n4 300     0 1175 3114 180:188 112:116 126:126 198:200 191:195\n5 305     0 1529 3237 154:170 122:124 124:126 188:192 181:195\n6 432     0 1336 2748 164:180 114:116 124:126 198:202 185:193\n```\n\n\n:::\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}